@import url('https://fonts.googleapis.com/css2?family=Great+Vibes&family=Libre+Franklin:ital,wght@0,100..900;1,100..900&display=swap');

@import url('https://fonts.googleapis.com/css2?family=Mr+Dafoe&display=swap');

@import url('https://fonts.googleapis.com/css2?family=Rock+Salt&display=swap');


:root {
	font-size: 100%;
	--padding: 1rem;
	--dropshadow: 0.1rem 0.15rem 0.2rem #2929293d;
	--dropshadow3: 0.25rem 0.25rem 0.6rem #2929296a;
	--dropshadow2: 0.55rem 0.55rem 1.2rem #29292981;
	--white: #F5F2ED;
	--transition: 300ms ease-in-out;
	--headerheight: 5rem;
	--headerheight2: 9rem;
	--navwidth: 16rem;
}

body::before{
	content:"";
	position: fixed;
	inset: 0;
	background-image: url("canvas.jpg");
	background-size: cover;
	background-position: center;
	z-index: -1;
	opacity: 80%;
}

body {
	overflow-x: hidden;
}

/* I wanted to blur everything except the hovered card (polaroid / text / document-shadow) */
/* I tried using the not selector, but after troubleshooting wtih chatGPT I realized the has selector would be an easier setup */

body::after {
	content: "";
	position: fixed;
	inset: 0;
	backdrop-filter: blur(0.08rem);
	pointer-events: none;
	z-index: 5;
	opacity: 0;
	transition: opacity var(--transition);
}

.blur {
	width: 100vw;
	height: 100vh; 
	background: rgba(255, 255, 255, 0);
	z-index: 9;
	position: fixed;
	backdrop-filter: blur(0.25rem);
	display: none;
	transition: var(--transition);
}

.bluractive {
	display: block;
	transition: var(--transition);
}

span {
	font-size: 1.2em;
	letter-spacing: -0.03em;
}

.linework {
  position: fixed;
  inset: 0;
  z-index: 0;
  pointer-events: none;
  mix-blend-mode: multiply;
  /* overflow: hidden; */
}

.linework svg {
	position: absolute;
	inline-size: 300%;
	display: block;
	inset-inline-end: 0;
}

#content {
	inline-size: 100vw;
	block-size: 100%;
	z-index: 1;
	display: grid;
	grid-template-columns: repeat(auto-fit, minmax(17rem, 1fr));
	column-gap: var(--padding);
	row-gap: var(--padding);
	padding-inline: var(--padding);
	padding-block-start: calc(4 * var(--padding));
	padding-block-end: calc(10 * var(--padding));
}

.polaroid, .blank, .document, .placeholder {
	inline-size: 100%;
	aspect-ratio: 2.8 / 4;
	block-size: auto;
}

.blank {
	display: none;
}

.placeholder {
	display: none;
}

.placeholder-active {
	display: block;
}

.polaroid {
	position: relative;
	box-shadow: var(--dropshadow);
	background-color: rgb(234, 234, 231);
	transition: var(--transition);
}

.polaroidimg, .polaroidcover {
	position: absolute;
	inset-block-start: calc(var(--padding)/2);
	inset-inline-start: calc(var(--padding)/2);
	inline-size: calc(100% - var(--padding));
	block-size: 80%;
}

.polaroidcover {
	z-index: 1;
	mix-blend-mode: lighten;
	opacity: 40%;
}

.template {
	position: absolute;
	inset: 0;
	inset-block-end: 3rem;
	margin: auto;
	inline-size: 28%;
	block-size: auto;
	z-index: 4;
	pointer-events: none;
	color: var(--white);
	transition: var(--transition);
}

/* Per Michael's instruction, I am using a symbol within an SVG to reference the SVG in Javascript. This CSS hides the original copy of the SVG that is in my HTML */
svg:has(symbol) { display: none; }

img, picture {
	inline-size: 100%;
	block-size: 100%;
	object-fit: cover;
	aspect-ratio: auto;
	display: block;
	overflow: hidden;
	position: absolute;
	object-position: top center; 
}

.text, .caption {
	color: black;
	inline-size: calc(100% - (2 * var(--padding)));
	padding: var(--padding);
	align-self: start;
	margin-block-start: calc(2 * var(--padding));
	box-shadow: var(--dropshadow);
	transition: var(--transition);
	margin-inline: var(--padding);
}

.text, .caption, .polaroid, .document-shadow {
	transform: translateY(calc(-2* var(--translate))) rotate(var(--rotation)) translateX(var(--translate));
}

.text {
	position: relative;
	background: #fff5d9;
	background: linear-gradient(0deg, rgb(252, 239, 204) 0%, rgba(255, 244, 176, 1) 100%);
	aspect-ratio: 1;
}

.caption {
	background: #fff5d9;
	background: linear-gradient(0deg, rgb(203, 250, 255) 0%, rgb(181, 245, 255) 100%);
	position: fixed;
	display: none;
	z-index: 14;
	inset-inline-end: 0;
	height: auto;
	width: calc(100vw - (2 * var(--padding)));
	box-shadow: var(--dropshadow3);
	padding-block-end: calc(var(--padding) * 5);
	inset-block-end: calc(2 * var(--padding));
}

.caption-active {
	display: block;
	transition: var(--transition);
}

.text::after, .document::after, .caption::after{
	content:"";
	position:absolute;
	inset: 0;
	background-image: url("paper-grain.jpg");
	background-size: cover;
	background-repeat: repeat;
	pointer-events:none;
	mix-blend-mode: multiply;
	opacity: 0.6;
	filter: contrast(140%) brightness(105%);
}

p, h2, .buttonstyle {
	font-family: "Rock Salt", cursive;
	font-weight: 400;
	font-style: normal;
	font-size: 0.9rem;
	line-height: 1.2rem;
}

.buttonstyle {
	text-align: center;
}

.buttonstyle, #dialog button {
	background-color: rgba(255, 244, 176, 1);
	padding-inline: var(--padding);
	padding-block: calc(var(--padding) / 2);
	bottom: calc(1 * var(--padding));
	position: absolute;
	transition: var(--transition);
	mix-blend-mode: normal;
}

.navigation .buttonstyle {
	position: static;
	height: calc(var(--headerheight2) / 4);
}

#dialog {
	inline-size: calc(100% - (10 * var(--padding)));
	height: 100%;
	position: relative;
	transition: var(--transition);
	inset-block-start: 0;
	inset-inline-end: 0;
	width: 100vw;
}

#dialog .text {
	aspect-ratio: 1;
	width: calc(100vh - (2 * var(--padding)));
	inset-inline-start: 50%;
	inset-block-start: 50%;
	transform: translate(-50%, -50%);
	position: fixed;
	transition: var(--transition);
	background: #fff5d9;
	background: linear-gradient(0deg, rgb(203, 250, 255) 0%, rgb(181, 245, 255) 100%);
}

body:has(dialog[open]) { overflow: hidden; }

#content h2 {
	font-size: 1.5rem;
	margin-block-end: var(--padding);
	line-height: 2.1rem;
}

#modal, #closebutton {
	position: fixed;
	inset-block-start: calc(var(--padding) /2);
	inset-inline-start: calc(var(--padding) /2);
	scale: 50%;
	z-index: 500;
	display: block;
	transition: var(--transition);
	color: black;
}

#closebutton {
	inset-block-start: -1.4rem;
	display: none;
}

#modal.is-hidden {
	display: none;
}

#closebutton.is-visible {
	display: block;
}

/* I wanted to use an svg file as a mask to make my PDF files look torn */
/* I used a LLM to learn about the webkit mask-image property, and read more here: https://developer.mozilla.org/en-US/docs/Web/CSS/Reference/Properties/mask-image */
/* This works because the image is set to cover the entire svg, regardless of size, making it a responsive mask setup */

.document-shadow{
	filter: drop-shadow(var(--dropshadow));
	display: inline-block;
	transition: var(--transition);
}

.document{
	-webkit-mask-image: url("torn-mask.svg");
	-webkit-mask-size: cover;
	-webkit-mask-repeat: no-repeat;
	-webkit-mask-position: center;
	mask-image: url("torn-mask.svg");
	mask-size: cover;
	mask-repeat: no-repeat;
	mask-position: center;
	position: relative;
	background: white;
	overflow: hidden;
}

.document img, .document picture {
	position: absolute;
	inset: 0;
	inline-size: 100%;
	block-size: 100%;
	object-fit: cover;
	object-position: top center;
	transform: scale(0.93);
	transform-origin: bottom center;
}

header {
	inline-size: 100%;
	position: fixed;
	inset-block-end: 0;
	inset-inline-start: 0;
	z-index: 8;
	/* mix-blend-mode: multiply; */
	transition: var(--transition);
	height: var(--headerheight2);
	background-image: url("paper2.jpg");
	background-size: cover;
	background-position: center;
	box-shadow: var(--dropshadow2);
	display: flex;
	flex-direction: column;
	align-items: start;
	padding-block-start: var(--padding);
}

.flexcolors{
	display: flex;
	align-items: center;
	justify-content: space-between;
	column-gap: calc(var(--padding) / 2);
	width: 100%;
	padding-inline: var(--padding);
	/* mix-blend-mode: multiply; */
	height: 100%;
}

.navigation {
	display: flex;
	align-items: center;
	height: calc(var(--headerheight2) / 4);
	mix-blend-mode: normal;
	width: 80%;
	justify-content: center;
	column-gap: calc(var(--padding) / 2);
	margin-inline-start: 10%;
}

.arrow {
	scale: 38%;
	transform: rotate(180deg);
}

.forward {
	transform: rotate(0deg) translateY(0.2rem);
}

.swatch, .swatch2, .swatch3 {
	-webkit-mask-image: url("swatch1.svg");
	-webkit-mask-size: cover;
	-webkit-mask-repeat: no-repeat;
	-webkit-mask-position: center;
	mask-image: url("swatch1.svg");
	mask-size: cover;
	mask-repeat: no-repeat;
	mask-position: center;
	height: 70%;
	aspect-ratio: 0.92;
	background-color: rgb(200, 124, 124);
}

.swatch2 {
	-webkit-mask-image: url("swatch2.svg");
	mask-image: url("swatch2.svg");
}

.swatch3 {
	-webkit-mask-image: url("swatch3.svg");
	mask-image: url("swatch3.svg");
}

.navigation p {
	margin: 0;
}

.open, .documentopen, .textopen {
	position: fixed;
	inset-inline-start: 50%;
	inset-block-start: calc(2 * var(--padding));
	transform: translate(-50%, 0);
	aspect-ratio: 2.8 / 4;
	z-index: 13;
	box-shadow: var(--dropshadow3);
	transition: var(--transition);
	max-height: calc(100vh - (4 * var(--padding)));
	height: auto;

/* I wanted to make sure the image would responsively resize for any viewport width or height while still maintaining the same aspect aspect-ratio */
/* I found the min () CSS function on MDN, which allows me to compute the largest width that fits within the available viewport: https://developer.mozilla.org/en-US/docs/Web/CSS/Reference/Values/min */
/* Here we are limiting the size of the image to respect the existing design system padding while allowing it to resize to the viewport accordingly */
	width: min(calc(100vw - (4 * var(--padding))),
	calc((100vh - (4 * var(--padding))) * (2.8 / 4)));
}

.documentopen {
	box-shadow: none;
	filter: drop-shadow(var(--dropshadow3));
	width: min(calc(100vw - (-2 * var(--padding))),
	calc((100vh - (-2 * var(--padding))) * (2.8 / 4)));
	inset-block-start: calc(-0.8 * var(--padding));
}

.textopen {
	position: fixed;
	aspect-ratio: 1;
	width: 24rem;
}

.textopen p {
	font-size: 1.4rem;
	line-height: 1.8rem;
	transition: var(--transition);
}

svg.palette1 { color:#2121DB; }
svg.palette2 { color:#FC7F5F; }
svg.palette3 { color:#F2C478; }
svg.palette4 { color:#87C9AE; }
svg.palette5 { color:#70838F; }

header .palette1 { background:#2121DB; }
header .palette2 { background:#FC7F5F; }
header .palette3 { background:#F2C478; }
header .palette4 { background:#87C9AE; }
header .palette5 { background:#70838F; }

@media (width > 1000px) {

.caption {
	width: 27vw;
	aspect-ratio: 1;
}

.linework svg {
	inset-block-end: 85vh;
	inline-size: 110%;
}

}

@media (width > 860px) {

	.blank {
	display: block;
	}

	:root {
	font-size: 125%;
	}

	.arrow {
	scale: 55%;
}
}

@media (width > 650px) {

header {
	height: var(--headerheight);
	flex-direction: row;
	padding-block-start: 0;
	justify-content: space-between;
	align-items: center;
}

.flexcolors{
	justify-content: right;
	column-gap: var(--padding);
	width: auto;
	padding-inline-start: 0;
}

.navigation {
	width: auto;
	margin-inline-start: 0;
	padding-inline-start: var(--padding);
	margin-inline-start: 0;
}

/* Here we activate the blur pseudo element each time one of the elements is hovered over */
body:has(.polaroid:hover)::after,
body:has(.text:hover)::after,
body:has(.document-shadow:hover)::after {
	opacity: 1;
}

#modal:hover, .arrow:hover {
	transition: var(--transition);
	color: rgba(0, 0, 0, 0.4);
}

#closebutton:hover {
	transition: var(--transition);
	color: rgba(0, 0, 0, 0.4);
}

.buttonstyle:hover, #dialog button:hover {
	transition: var(--transition);
	background-color: rgba(255, 255, 255, 0);
	background: none;
	box-shadow: inset 0 0 0.3rem #0808089c;
}

.polaroid.withvideo:hover .template {
	scale: 1.2;
	transform: rotate(-4deg);
	transition: var(--transition);
}

.polaroid:hover, .text:hover {
	box-shadow: var(--dropshadow2);
}

.document-shadow:hover {
	filter: drop-shadow(var(--dropshadow2));
}

.polaroid:hover, .text:hover, .document-shadow:hover {
	z-index: 7;
	transition: var(--transition);
}

.open.polaroid:hover, .textopen.text:hover, .documentopen.document-shadow:hover {
	z-index: 12;
}



}

@media (width < 370px) {
	.swatch, .swatch2, .swatch3 {
	height: 50%;
}

}
